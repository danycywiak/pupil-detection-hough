"""
Pupil detection using the Hough Circle Transform (classical Computer Vision).

What this script does:
1) Opens a video file.
2) Samples frames (every N frames).
3) Runs preprocessing + HoughCircles to detect the pupil as a circle.
4) Draws the detected circle and center on each processed frame.
5) Saves an output video with the overlay.

Notes:
- This is a classical, interpretable approach.
- HoughCircles is sensitive to illumination and blur parameters,
  so the thresholds/radius range should be tuned per camera setup.
"""

import cv2
import numpy as np
import subprocess


########## Open video and extract frames


# Path to the input video
video_path = "Chris_pupila2.mp4"

# Open the video using OpenCV
cap = cv2.VideoCapture(video_path)

# Get total number of frames in the video
total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
print(f"The maximum number of frames in the video is: {total_frames}")

# Lists to store the frames and their corresponding frame numbers
frames_to_analize = []
frame_num_tag = []

# We can skip frames if needed (for example, analyze every 2nd or 5th frame)
# Here I set it to 1, so we analyze all frames
frames_jumps = 1

# Loop over the video frames
for frame in range(0, total_frames, frames_jumps):
    # Move the video pointer to the desired frame
    cap.set(cv2.CAP_PROP_POS_FRAMES, frame)
    
    # Read the frame
    ret, actual_frame = cap.read()

    # Store a copy of the frame and its frame index
    frames_to_analize.append(actual_frame.copy())
    frame_num_tag.append(frame)

    # Optionally save the original frame without any drawings
    # cv2.imwrite(f"frame_original_{frame}.png", actual_frame)

# Release the video object
cap.release()

print(f"The number of frames that will be analyzed is {len(frames_to_analize)}")



########### Pupil detection using Hough Circles


# This list will store the detected pupil radius for each frame
circles_radius_data_array = []

# Loop over all extracted frames
for i in range(len(frames_to_analize)):

    # Copy the frame so we donâ€™t modify the original one
    img = frames_to_analize[i].copy()
    
    # Convert the image to grayscale (required for HoughCircles)
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    # Apply median blur to reduce noise and improve detection
    img_blur = cv2.medianBlur(img_gray, 9)

    # Detect circles using Hough Circle Transform
    circles = cv2.HoughCircles(
        img_blur,
        cv2.HOUGH_GRADIENT,
        dp=1,
        minDist=90,
        param1=40,
        param2=30,
        minRadius=17,
        maxRadius=60
    )

    # If at least one circle is detected
    if circles is not None:
        # Round values and convert to integers
        circles = np.uint16(np.around(circles))

        # Loop over detected circles
        for c in circles[0]:
            # c contains (x_center, y_center, radius)
            # OpenCV stores circles inside an extra array level,
            # so we access circles[0]

            # Draw the detected pupil circle in green
            cv2.circle(img, (c[0], c[1]), c[2], (0, 255, 0), 2)

            # Draw the center of the circle in red
            cv2.circle(img, (c[0], c[1]), 2, (0, 0, 255), 3)

            # Save the detected radius value
            radius = int(c[2])
            circles_radius_data_array.append(radius)

    else:
        # If no pupil is detected in this frame
        print(f"No circle detected in frame {frame_num_tag[i]}")

    
    # Save frame with pupil detection
  
    cv2.imwrite(f"frame_pupil_detected_{frame_num_tag[i]}.png", img)



########### Final summary of detection

print(
    f"\nThe number of frames with detected pupil is "
    f"{len(circles_radius_data_array)} out of {len(frames_to_analize)} total frames."
)
print("Detected radii (in pixels):")
print(circles_radius_data_array)
print("Program finished successfully")


# ----Create a video using the processed frames


fps = 15
output_video = "Prueba_Chris_pupil_detected.mp4"

# Read the first processed frame to get video size
first_frame = cv2.imread(f"frame_pupil_detected_{frame_num_tag[0]}.png")
height = first_frame.shape[0]
width = first_frame.shape[1]

# Create the VideoWriter object
codec = cv2.VideoWriter_fourcc(*"mp4v")
video = cv2.VideoWriter(output_video, codec, fps, (width, height))

# Write each processed image as a frame in the output video
# This produces a low-quality video due to the mp4v codec
for n in frame_num_tag:
    imgage = cv2.imread(f"frame_pupil_detected_{n}.png")
    video.write(imgage)

video.release()

print("Video:", output_video, "created successfully")





########## Convert the video to high-quality H.264 using ffmpeg


output_h264 = "Chris_pupil_detected_h264_q12.mp4"

# Use ffmpeg to re-encode the video with better quality
subprocess.run([
    "ffmpeg", "-y",
    "-i", output_video,
    "-c:v", "libx264",
    "-crf", "12",
    "-preset", "veryfast",
    "-pix_fmt", "yuv420p",
    "-movflags", "+faststart",
    output_h264
])

print("H.264 video (q12) created:", output_h264)

